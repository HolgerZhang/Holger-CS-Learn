# 链表类模板 LinkedList

2020.1.31 by Holger.

#### 使用说明文档

0. 需包含头文件 "LinkedList.h"

1. 创建链表： 

   ```c++
   LinkedList<数据类型T> 链表名 [ = 另一链表 ]; //可用另一同类型链表初始化
   ```

2. 可使用运算符：

   | 运算符             | 说明                                               |
   | :----------------- | :------------------------------------------------- |
   | 赋值运算符    =    | 用另一同类型链表初始化本列表                       |
   | 下标运算符    []   | 下标索引访问（会改变索引位置）                                       |
   | 加法运算符    +    | 将两个链表拼接，返回拼接的两个链表（会改变索引位置）              |
   | 复合运算符    +=   | 将两个链表拼接，并将拼接的结果赋给前者；相当于extend()（会改变索引位置）|
   | 乘法运算符    *    | 返回将一个链表的深拷贝重复n次（会改变索引位置）                      |
   | 复合运算符    *=   | 赋给前者一个链表的深拷贝重复n次（会改变索引位置）                    |
   | 流插入运算符    << | 用于向cout输出链表对象（会改变索引位置）                             |

3. 基础数据接口：

   | 方法      | 原型                    | 说明                                             |
   | --------- | ----------------------- | ------------------------------------------------ |
   | length()  | int length() const;     | 获取元素个数                                     |
   | isEmpty() | bool isEmpty() const;   | 判断是否为空链表                                 |
   | data()    | T &data();              | 返回当前位置元素数据的引用                       |
   |           | const T &data() const ; | 返回当前位置元素数据的常引用                     |
   | find(pos) | T &find(int pos);       | 返回指定位置元素成员数据的引用（会改变索引位置） |
   | copy()    | LinkedList<T> &copy();  | 获得链表的深拷贝对象                             |

4. 索引（下标）方法：

   | 方法    | 原型                   | 说明                     |
   | ------- | ---------------------- | ------------------------ |
   | reset([pos]) | void reset(int pos=0); | 初始化索引位置           |
   | next()  | void next();           | 索引指向下一个元素       |
   | isEnd() | bool isEnd() const;    | 判断索引是否到达表的末尾 |
   | index() | int index() const;     | 返回索引位置             |

5. 数据处理方法:

   (1) 插入数据

   | 方法          | 原型                         | 说明                   |
   | ------------- | ---------------------------- | ---------------------- |
   | headin(item)  | void headin(const T &item);  | 在头部插入数据         |
   | append(item)  | void append(const T &item);  | 在末尾插入数据         |
   | insertf(item) | void insertf(const T &item); | 在当前位置之前插入数据 |
   | insert(item)  | void insert(const T &item);  | 在当前位置之后插入数据 |

   (2) 扩展

   | 方法      | 原型                           | 说明                             |
   | --------- | ------------------------------ | -------------------------------- |
   | extend(L) | void extend(LinkedList<T> &L); | 用一个同类型的链表对象扩展本对象（会改变索引位置） |

   (3) 删除数据

   | 方法     | 原型           | 说明               |
   | -------- | -------------- | ------------------ |
   | rmf()    | T rmf();       | 删除并返回起始元素 |
   | rml()    | T rml();       | 删除并返回末尾元素 |
   | remove() | T remove(); | 删除并返回当前位置元素   |

   (4) 处理数据

   | 方法               | 原型                           | 说明                                                         |
   | ------------------ | ------------------------------ | ------------------------------------------------------------ |
   | clear()            | void clear();                  | 清空链表，但保留链表对象             |
   | input(number)      | void input(int number);        | 数据批量输入                                                 |
   | show()             | void show();                   | 链表对象输出，也可以用<<作用于cout等                         |
   | sort([false/true]) | void sort(bool reverse=false); | 原地排序(冒泡排序法)，reverse参数用来确定是否倒序，默认升序 (仅适用于支持排序的数据类型) |
   | reverse()          | void reverse();                | 原地翻转                                                     |

   